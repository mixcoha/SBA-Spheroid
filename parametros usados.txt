 <!--
    1 voxel (side)= 4 um
    1 voxel (volume)= 64 um^3
    density of lattice ~ density of water
    Total simulated mass = 50*50*80 *(4um)^3 gram/cm^3= 1.28*10^-5 gram
    1 MCS ~ `min (typical)
    tumor cell volume = 32 voxels * 64 um^3/voxel = 2048 um^3
    fastest (simulated) tumor cell cycle is 24hours or 1440 mcs when glucose is high so 32voxels/1440mcs= 0.022 voxel/mcs
    tumor cell growth equation;
          cell.targetVolume+=0.022*GlucoseConcentration/(0.05 + GlucoseConcentration)

    Glucose diffusion Coeff = 600 um^2/sec = 600 um^2/sec *(voxel/4um)^2 * (60sec/MCS)=2250 voxel^2/MCS
    Glucose Uptake (Stromal Tissue)= 0.1 umol/gram/min (estimated)
    Glucose Uptake (Tumor)~ 0.3 umol/g/min (exprimentally measured [http://cancerres.aacrjournals.org/content/48/24_Part_1/7264.short])

    Total Glucose Uptake (simulated stroma without tumor) ~ 1.28*10^-5 gram * 0.1 umol/gram/min
                            = 1.28 pmol/min
                            = 1.28 pmol/MCS

    Total # of Vacular cells = 24 cells
    Glucose Secereted per Vascular Cell = 1.28/24 pmol/MCS/cell = 0.053 pmol/MCS/cell
    Glucose Secereted per Voxel of Vascular Cell =  Glucose Secereted per Vascular Cell/(cell volume)
                             = 0.053/64 pmol/MCS/voxel = 0.0008 pmol/MCS/voxel
                             =0,8 fmol/MCS/voxel
   Typical Glucose Uptake by Medium (stroma) voxel = 1.28 pmol/MCS/(~20000 Medium voxels) =6.4*10^-6 pmol/MCS/voxel
                        = 6.4*10^-3 fmol/MCS/voxel
    (assumed) Max Glucose Uptake by Medium (stroma) voxel = 1.28 * 10^-2 fmol/MCS/voxel
    typical tumor cell density in tumor ~ 10^8 cells/cm^3
    Glucose Uptake by a tumor cell ~  (0.3 umol/g/mcs)/(10^8 cells per gram)
                  = 0.003 pmol/mcs/cell
                  = 0.003 pmol/mcs/(32 voxel)
                  ~ 10^-4 pmol/MCS/voxel
                  = 0.1 fmol/MCS/voxel

    (assumed) Max Glucose Uptake by a tumor cell = 0.2 fmol/MCS/voxel

    Max stable FlexibleDiffusionSolverFE diffusion constant in 3D ~ 0.15 voxel^2/MCS
    Number of Field updates per MCS needed (ExtraTimesPerMC) = 2250 voxel^2/MCS/0.15= 15000 field updates per MCS
    we set ExtraTimesPerMC=9 (10 updates), so glucose diffusion is 1500 slower, resulting in steep glucose gradients and smaller tumors
    -->





from cc3d.core.PySteppables import *
import numpy as np
import random
import logging
import gc
import os


# Configurar el logger

# Definir carpeta de salida
OUTPUT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "results")
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Configurar el logger para que guarde dentro de results
logging.basicConfig(
    filename=os.path.join(OUTPUT_DIR, 'cambios_simulacion.log'),
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# -----------------------------------------------------------------------------------
# Definici√≥n de constantes para la simulaci√≥n
#  Fuentes de datos experimentales:
# - Volumen celular y tiempos de duplicaci√≥n:
#   - Chen et al., 2013, "Single-cell analysis of cell size and cell cycle phase in MCF7 cells"
#   - Sinha et al., 2011, "Cell volume and drug uptake in MCF7 breast cancer cells"
#   - Gong et al., 2015, "Tracking volume and density of MCF7 cells using digital holographic microscopy"
# - Consumo metab√≥lico (glucosa, ox√≠geno):
#   - Basado en simulaciones de CompuCell3D de tejido tumoral est√°ndar.
#   - Consumo tumoral de glucosa: Cancer Res, 1988 ([enlace](http://cancerres.aacrjournals.org/content/48/24_Part_1/7264.short)).
#
#  Justificaci√≥n de tiempos de transici√≥n fenot√≠pica y muerte celular:
# - Tiempos de ciclo celular: ~30-50 horas para c√©lulas tumorales MCF7 bajo condiciones favorables.
# - Transiciones de estr√©s/muerte definidas en escalas de:
#   - 6‚Äì12 horas (transici√≥n leve: PROL ‚Üí RESE)
#   - 24‚Äì48 horas (transici√≥n severa: RESE ‚Üí INVA)
#   - 8‚Äì12 horas (recuperaci√≥n: RESE ‚Üí PROL)
#   - 16‚Äì48 horas (reversi√≥n: INVA ‚Üí RESE)
# - Muerte celular: Acumulaci√≥n de da√±o severo ‚â•15 horas continuas (DEATH_DELAY + DEATH_MCS_THRESHOLD).
# -----------------------------------------------------------------------------------

# Definici√≥n de constantes para los tipos de c√©lulas
CELL_TYPE_PROL = 1  # Proliferativa
CELL_TYPE_RESE = 2  # Reserva
CELL_TYPE_INVA = 3  # Invasiva
CELL_TYPE_NECR = 4  # Necr√≥tica

# Definici√≥n de constantes para umbrales y par√°metros metab√≥licos
MCS_INIT_EVO = 72   # (Acortado) ~6 horas para formaci√≥n inicial del microambiente
o2_THRESHOLD = 180  # ¬µM - nivel √≥ptimo de ox√≠geno
o2_THRESHOLD_HIPO = 15  # ¬µM - hipoxia severa
glc_THRESHOLD = 10  # mM - concentraci√≥n alta de glucosa
glc_THRESHOLD_HIPO = 0.5  # mM - hipoglucemia severa
lac_THRESHOLD_ACIDIC = 10  # mM - estr√©s √°cido
lac_THRESHOLD_TOXIC = 20   # mM - toxicidad severa

# Par√°metros de volumen y crecimiento
INITIAL_TARGET_VOLUME = 32  # voxels (~2048 ¬µm¬≥)
INITIAL_LAMBDA_VOLUME = 2.0
MITOSIS_VOLUME_THRESHOLD = 64  # Volumen duplicado para divisi√≥n
GROWTH_RATE_PROL = 0.022  # voxels por MCS

# pH √≥ptimo para proliferaci√≥n
OPTIMAL_h3o = 7.2  # pH 7.2 (condiciones fisiol√≥gicas)

# Par√°metros de mutaci√≥n y muerte
MUTATION_PERC = 0.05  # 5% de c√©lulas elegibles para mutar
MUTATION_DELAY = 288  # ~24 horas para permitir microambiente maduro
DEATH_DELAY = 180     # ~15 horas de exposici√≥n cr√≠tica para activar muerte
MUTATION_PROBABILITY = 0.01  # Baja tasa de mutaci√≥n aleatoria

# Umbrales de cambio fenot√≠pico (en MCS)
MCS_PROL_TO_RESE = 144     # 6‚Äì12 horas (estr√©s moderado)
MCS_RESE_TO_INVA = 288     # 24‚Äì48 horas (estr√©s severo)
MCS_RESE_TO_PROL = 96      # 8‚Äì12 horas (recuperaci√≥n parcial)
MCS_INVA_TO_RESE = 192     # 16‚Äì48 horas (normalizaci√≥n ambiental)
DEATH_MCS_THRESHOLD = 180  # 12‚Äì15 horas (estr√©s sostenido antes de morir)


class EnvironmentEvaluator:
    def __init__(self, field_accessor):
        self.fields = field_accessor
        self.O2_OPTIMAL = 180
        self.GLC_OPTIMAL = 10
        self.LAC_OPTIMAL = 2.0
        self.TOL_O2 = 40
        self.TOL_GLC = 2
        self.TOL_LAC = 1

    def is_optimal(self, cell):
        o2 = self.fields.get(cell, 'o2')
        glc = self.fields.get(cell, 'glc')
        lac = self.fields.get(cell, 'lac')

        o2_ok = abs(o2 - self.O2_OPTIMAL) <= self.TOL_O2
        glc_ok = abs(glc - self.GLC_OPTIMAL) <= self.TOL_GLC
        lac_ok = abs(lac - self.LAC_OPTIMAL) <= self.TOL_LAC

        return o2_ok and glc_ok and lac_ok
        
    def is_stressed(self, cell):
        o2 = self.fields.get(cell, 'o2')
        glc = self.fields.get(cell, 'glc')
        lac = self.fields.get(cell, 'lac')
    
        o2_stress = o2 < o2_THRESHOLD_HIPO
        glc_stress = glc < glc_THRESHOLD_HIPO
        lac_high = lac > lac_THRESHOLD_ACIDIC  # Less severe than toxic
    
        return o2_stress and glc_stress
        
class FieldAccessor:
    def __init__(self, field_obj, default=0.0):
        """
        Acceso seguro a campos qu√≠micos.
        Recupera las dimensiones del espacio de simulaci√≥n directamente.
        """
        self.fields = field_obj
        self.default = default

        try:
            simulator = get_simulator()
            self.dim = simulator.getPotts().getCellFieldG().getDim()
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è FieldAccessor: no se pudo obtener dimensiones del simulador: {e}")
            self.dim = None

    def get(self, cell, field_name):
        try:
            if cell is None:
                return self.default

            field_name = field_name.lower()
            field = getattr(self.fields, field_name, None)

            if field is None:
                logging.warning(f"‚ö†Ô∏è Campo '{field_name}' no disponible.")
                return self.default

            x, y, z = int(cell.xCOM), int(cell.yCOM), int(cell.zCOM)

            if self.dim:
                if not (0 <= x < self.dim.x and 0 <= y < self.dim.y and 0 <= z < self.dim.z):
                    return self.default

            return field[x, y, z]

        except Exception as e:
            logging.warning(f"‚ö†Ô∏è Error accediendo a campo '{field_name}' en c√©lula {getattr(cell, 'id', 'None')}: {e}")
            return self.default

class ConstraintInitializerSteppable(SteppableBasePy):
    def __init__(self, frequency=1):
        super().__init__(frequency)
        self.initialized = False

    def start(self):
        try:
            if self.initialized:
                return

            for cell in self.cell_list:
                if cell is None:
                    continue
                if cell.type in [CELL_TYPE_PROL, CELL_TYPE_RESE, CELL_TYPE_INVA]:
                    cell.targetVolume = INITIAL_TARGET_VOLUME
                    cell.lambdaVolume = INITIAL_LAMBDA_VOLUME
                else:
                    cell.targetVolume = 20  # Para c√©lulas necr√≥ticas u otras
                    cell.lambdaVolume = 50

            self.initialized = True
            gc.collect()  # Limpieza de memoria
        except Exception as e:
            logging.error(f"Error en ConstraintInitializerSteppable.start: {str(e)}")
            self.initialized = False

class GrowthSteppable(SteppableBasePy):
    def __init__(self, frequency=1):
        super().__init__(frequency)
        self.field_accessor = None
        self.env = None
        self.growth_log = []  # Lista para guardar los datos de crecimiento

    def start(self):
        try:
            if not hasattr(self.field, 'o2') or self.field.o2 is None:
                logging.error("Campo o2 no disponible o es None")
                return

            self.field_accessor = FieldAccessor(self.field)
            self.env = EnvironmentEvaluator(self.field_accessor)
            logging.info("‚úÖ FieldAccessor inicializado en GrowthSteppable")
        except Exception as e:
            logging.error(f"‚ùå Error en GrowthSteppable.start: {str(e)}")

    def get_metabolic_values(self, cell):
        """Accede a los valores metab√≥licos usando FieldAccessor."""
        if not self.field_accessor or cell is None:
            return (0.0, 0.0, 0.0, 0.0)

        o2 = self.field_accessor.get(cell, 'o2')
        glc = self.field_accessor.get(cell, 'glc')
        h3o = self.field_accessor.get(cell, 'h3o')
        lac = self.field_accessor.get(cell, 'lac')

        return (o2, glc, h3o, lac)

    def step(self, mcs):
        """Ejecuta el paso de crecimiento para todas las c√©lulas no necr√≥ticas."""
        try:
            if not self.field_accessor or not self.env:
                return

            for cell in self.cell_list:
                if cell is None or cell.type == CELL_TYPE_NECR:
                    continue

                try:
                    o2_conc, glc_conc, h3o_conc, lac_conc = self.get_metabolic_values(cell)
                    self.calculate_growth(cell, o2_conc, glc_conc, h3o_conc, lac_conc)
                except Exception as e:
                    if mcs % 50 == 0:
                        logging.error(f"Error procesando c√©lula {cell.id if cell else 'None'}: {str(e)}")
                    continue
    
            if mcs % 100 == 0:
                gc.collect()
    
        except Exception as e:
            if mcs % 50 == 0:
                logging.error(f"Error en GrowthSteppable.step: {str(e)}")

    def calculate_growth(self, cell, o2, glc, h3o, lac):
        """
        Aplica crecimiento de volumen seg√∫n el tipo celular y la concentraci√≥n local de glucosa.
        """
        if not self.env.is_optimal(cell):
            return

        # Tasas de crecimiento base seg√∫n fenotipo
        base_growth_rates = {
            CELL_TYPE_PROL: 0.022,  # Proliferativas
            CELL_TYPE_RESE: 0.01,   # Reservorio
            CELL_TYPE_INVA: 0.015   # Invasivas
        }

        growth_base = base_growth_rates.get(cell.type, 0.005)

        # F√≥rmula Michaelis-Menten para la glucosa
        effective_glc = max(glc, 0.001)  # evitar divisi√≥n por cero
        growth_factor = effective_glc / (0.05 + effective_glc)
        delta_volume = growth_base * growth_factor
        

        cell.targetVolume += delta_volume

        # Guardar en el log
        self.growth_log.append({
            'MCS': self.simulator.getStep(),
            'CellID': cell.id,
            'Type': cell.type,
            'DeltaVolume': round(delta_volume, 4),
            'NewTargetVolume': round(cell.targetVolume, 2),
            'LocalGLC': round(glc, 2)
        })

    def finish(self):
        try:
            # Guardar volumen final de c√©lulas
            with open("volumen_final_celulas.csv", "w", newline="") as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(["Cell ID", "Type", "Current Volume", "Target Volume"])
                for cell in self.cell_list:
                    if cell is None:
                        continue
                    tipo_nombre = {
                        CELL_TYPE_PROL: "PROL",
                        CELL_TYPE_RESE: "RESE",
                        CELL_TYPE_INVA: "INVA",
                        CELL_TYPE_NECR: "NECR"
                    }.get(cell.type, f"Type {cell.type}")
                    writer.writerow([
                        cell.id,
                        tipo_nombre,
                        round(cell.volume, 2),
                        round(cell.targetVolume, 2)
                    ])

            # Guardar log de crecimiento
            output_path_growth = os.path.join(self.output_dir, "growth_log.csv")
            with open("growth_log.csv", "w", newline="") as logfile:
                fieldnames = ['MCS', 'CellID', 'Type', 'DeltaVolume', 'NewTargetVolume', 'LocalGLC']
                writer = csv.DictWriter(logfile, fieldnames=fieldnames)
                writer.writeheader()
                for entry in self.growth_log:
                    writer.writerow(entry)

            logging.info("üì§ Exportaciones finalizadas: volumen_final_celulas.csv y growth_log.csv")

        except Exception as e:
            if mcs % 50 == 0:
                logging.error(f"‚ùå Error exportando archivos al finalizar la simulaci√≥n: {e}")


class MitosisSteppable(MitosisSteppableBase):
    def __init__(self, frequency=1):
        super().__init__(frequency)

    def step(self, mcs):
        if mcs < MCS_INIT_EVO:
            return

        cells_to_divide = []

        for cell in self.cell_list:
            if cell.type == CELL_TYPE_NECR:
                continue  # Omitir c√©lulas necr√≥ticas

            if cell.volume > MITOSIS_VOLUME_THRESHOLD:  # ‚Üê Aqu√≠ ya usa el correcto
                cells_to_divide.append(cell)

        for cell in cells_to_divide:
            self.divide_cell_random_orientation(cell)

    def update_attributes(self):
        parent_cell = self.parent_cell
        parent_cell.targetVolume /= 2.0  # Dividir volumen de la madre en 2
        self.clone_parent_2_child()
        
class DeathSteppable(SteppableBasePy):
    def __init__(self, frequency=1):
        super().__init__(frequency)
        self.critical_condition_counter = {}
        self.field_accessor = None
        self.env = None

    def start(self):
        try:
            if not hasattr(self.field, 'o2') or self.field.o2 is None:
                logging.error("Campo o2 no disponible en DeathSteppable")
                return
            self.field_accessor = FieldAccessor(self.field)
            self.env = EnvironmentEvaluator(self.field_accessor)
            logging.info("‚úÖ FieldAccessor y EnvironmentEvaluator inicializados en DeathSteppable")
        except Exception as e:
            logging.error(f"Error inicializando FieldAccessor en DeathSteppable: {e}")

    def step(self, mcs):
        if mcs < DEATH_DELAY or not self.field_accessor or not self.env:
            return

        try:
            # Limpiar IDs de c√©lulas eliminadas
            cell_ids_actuales = {cell.id for cell in self.cell_list}
            ids_a_eliminar = set(self.critical_condition_counter.keys()) - cell_ids_actuales
            for dead_cell_id in ids_a_eliminar:
                del self.critical_condition_counter[dead_cell_id]

            for cell in self.cell_list:
                if cell.type == CELL_TYPE_NECR:
                    continue

                o2_conc = self.field_accessor.get(cell, 'o2')
                glc_conc = self.field_accessor.get(cell, 'glc')
                lac_conc = self.field_accessor.get(cell, 'lac')

                if cell.id not in self.critical_condition_counter:
                    self.critical_condition_counter[cell.id] = 0

                # üî• Ambiente estresante
                if self.env.is_stressed(cell):
                    if cell.type == CELL_TYPE_INVA and lac_conc > lac_THRESHOLD_TOXIC:
                        self.critical_condition_counter[cell.id] = max(0, self.critical_condition_counter[cell.id] - 1)
                    else:
                        self.critical_condition_counter[cell.id] += 1

                # ‚úÖ Recuperaci√≥n
                elif o2_conc >= o2_THRESHOLD_HIPO and glc_conc >= glc_THRESHOLD_HIPO:
                    self.critical_condition_counter[cell.id] = max(0, self.critical_condition_counter[cell.id] - 2)

                # üíÄ Muerte por estr√©s prolongado
                if self.critical_condition_counter[cell.id] >= DEATH_MCS_THRESHOLD:
                    cell.type = CELL_TYPE_NECR
                    cell.targetVolume = 25
                    cell.lambdaVolume = 50.0
                    logging.info(f"üíÄ MCS {mcs}: C√©lula {cell.id} ha muerto tras {self.critical_condition_counter[cell.id]} MCS en estr√©s.")

            if mcs % 100 == 0:
                gc.collect()

        except Exception as e:
            if mcs % 50 == 0:
                logging.error(f"Error en DeathSteppable.step: {str(e)}")      

                
class MutationSteppable(SteppableBasePy):
    def __init__(self, frequency=1):
        super().__init__(frequency)
        self.mutation_count = 0
        self.mutation_interval = 500
        self.cell_conditions = {}
        self.mutation_percentage = MUTATION_PERC
        self.initial_mutation_delay = MUTATION_DELAY
        self.transition_counts = {
            "PROL‚ÜíRESE": 0,
            "RESE‚ÜíINVA": 0,
            "RESE‚ÜíPROL": 0,
            "INVA‚ÜíRESE": 0
        }
        self.field_accessor = None

    def start(self):
        if not hasattr(self.field, 'o2') or self.field.o2 is None:
            logging.error("Campo o2 no disponible o es None")
            return
        self.field_accessor = FieldAccessor(self.field)
        self.env = EnvironmentEvaluator(self.field_accessor)

    def step(self, mcs):
        if mcs < self.initial_mutation_delay or not self.field_accessor:
            return

        for cell in self.cell_list:
            if cell.type == CELL_TYPE_NECR:
                continue

            o2_conc = self.field_accessor.get(cell, 'o2')
            glc_conc = self.field_accessor.get(cell, 'glc')
            lac_conc = self.field_accessor.get(cell, 'lac')

            self.check_and_mutate(cell, o2_conc, glc_conc, lac_conc, mcs)
            self.update_condition_counters(cell, o2_conc, glc_conc, lac_conc)
            self.apply_phenotype_changes(cell, mcs)

        self.perform_random_mutations(mcs)
    
    def check_and_mutate(self, cell, o2_conc, glc_conc, lac_conc, mcs):
        """Verifica si una c√©lula puede mutar seg√∫n las condiciones del microambiente."""
        if cell.type in [CELL_TYPE_PROL, CELL_TYPE_RESE, CELL_TYPE_INVA]:
            if o2_conc < o2_THRESHOLD and glc_conc < glc_THRESHOLD:
                new_type = self.get_new_cell_type(cell.type)
                cell.type = new_type
                self.mutation_count += 1
                logging.info(f"üî¨ C√©lula {cell.id} mut√≥ a tipo {new_type} debido a hipoxia en MCS {mcs}.")    
                            
    def update_condition_counters(self, cell, o2_conc, glc_conc, lac_conc):
        """
        Actualiza contadores para transici√≥n de fenotipos basada en el entorno metab√≥lico.
        Se consideran los 4 posibles cambios:
        - PROL ‚Üí RESE
        - RESE ‚Üí INVA
        - RESE ‚Üí PROL
        - INVA ‚Üí RESE
        """
    
        if cell.id not in self.cell_conditions:
            self.cell_conditions[cell.id] = {
                'low_o2_low_glu_prol_to_rese': 0,
                'low_o2_low_glu_rese_to_inva': 0,
                'high_o2_high_glu_rese_to_prol': 0,
                'high_o2_high_glu_inva_to_rese': 0,
            }
    
        conditions = self.cell_conditions[cell.id]
    
        # --------------------------------------
        # üîÅ PROLIFERATIVA ‚Üí RESERVA (estr√©s leve)
        # --------------------------------------
        if cell.type == CELL_TYPE_PROL and (o2_THRESHOLD_HIPO <= o2_conc <= o2_THRESHOLD and glc_THRESHOLD_HIPO <= glc_conc <= glc_THRESHOLD):
            conditions['low_o2_low_glu_prol_to_rese'] += 1
            logging.info(f"‚ö†Ô∏è C√©lula {cell.id} (PROL) puede volverse RESE en {MCS_PROL_TO_RESE - conditions['low_o2_low_glu_prol_to_rese']} MCS")
        else:
            conditions['low_o2_low_glu_prol_to_rese'] = max(0, conditions['low_o2_low_glu_prol_to_rese'] - 2)
    
        # --------------------------------------
        # üîÅ RESERVA ‚Üí INVASIVA (estr√©s severo)
        # --------------------------------------
        if cell.type == CELL_TYPE_RESE and self.env.is_stressed(cell):
            conditions['low_o2_low_glu_rese_to_inva'] += 1
            logging.info(f"‚ö†Ô∏è C√©lula {cell.id} (RESE) en estr√©s ‚Üí puede volverse INVA en {MCS_RESE_TO_INVA - conditions['low_o2_low_glu_rese_to_inva']} MCS")
        else:
            conditions['low_o2_low_glu_rese_to_inva'] = max(0, conditions['low_o2_low_glu_rese_to_inva'] - 2)
    
        # --------------------------------------
        # üîÅ RESERVA ‚Üí PROLIFERATIVA (recuperaci√≥n)
        # --------------------------------------
        if cell.type == CELL_TYPE_RESE:
            if self.env.is_optimal(cell):
                conditions['high_o2_high_glu_rese_to_prol'] += 1
                logging.info(f"üü¢ C√©lula {cell.id} (RESE) en ambiente √≥ptimo: revertir√° a PROL en {MCS_RESE_TO_PROL - conditions['high_o2_high_glu_rese_to_prol']} MCS")
            elif o2_conc > o2_THRESHOLD_HIPO and glc_conc > glc_THRESHOLD_HIPO:
                conditions['high_o2_high_glu_rese_to_prol'] += 1
                logging.info(f"üü¢ C√©lula {cell.id} (RESE) en buenas condiciones: revertir√° a PROL en {MCS_RESE_TO_PROL - conditions['high_o2_high_glu_rese_to_prol']} MCS")
            else:
                conditions['high_o2_high_glu_rese_to_prol'] = max(0, conditions['high_o2_high_glu_rese_to_prol'] - 2)
    
        # --------------------------------------
        # üîÅ INVASIVA ‚Üí RESERVA (reversi√≥n)
        # --------------------------------------
        if cell.type == CELL_TYPE_INVA:
            if self.env.is_optimal(cell):
                conditions['high_o2_high_glu_inva_to_rese'] += 1
                logging.info(f"üü¢ C√©lula {cell.id} (INVA) en ambiente √≥ptimo: revertir√° a RESE en {MCS_INVA_TO_RESE - conditions['high_o2_high_glu_inva_to_rese']} MCS")
            elif o2_conc >= o2_THRESHOLD_HIPO and glc_conc >= glc_THRESHOLD_HIPO:
                conditions['high_o2_high_glu_inva_to_rese'] += 1
                logging.info(f"üü¢ C√©lula {cell.id} (INVA) en buenas condiciones: revertir√° a RESE en {MCS_INVA_TO_RESE - conditions['high_o2_high_glu_inva_to_rese']} MCS")
            else:
                conditions['high_o2_high_glu_inva_to_rese'] = max(0, conditions['high_o2_high_glu_inva_to_rese'] - 2)

    def apply_phenotype_changes(self, cell, mcs):
        """
        Aplica los cambios de fenotipo en la c√©lula seg√∫n los contadores de condici√≥n.
        Cada transici√≥n tiene su propio umbral temporal definido en MCS.
        """
    
        if mcs < self.initial_mutation_delay:
            return
    
        conditions = self.cell_conditions[cell.id]
    
        # PROL ‚Üí RESE
        if conditions['low_o2_low_glu_prol_to_rese'] >= MCS_PROL_TO_RESE:
            cell.type = CELL_TYPE_RESE
            self.transition_counts["PROL‚ÜíRESE"] += 1
            logging.info(f"üîÑ PROL ‚Üí RESE in cell {cell.id} at MCS {mcs}")
    
        # RESE ‚Üí INVA
        elif conditions['low_o2_low_glu_rese_to_inva'] >= MCS_RESE_TO_INVA:
            cell.type = CELL_TYPE_INVA
            self.transition_counts["RESE‚ÜíINVA"] += 1
            logging.info(f"üîÑ RESE ‚Üí INVA in cell {cell.id} at MCS {mcs}")
    
        # RESE ‚Üí PROL
        elif conditions['high_o2_high_glu_rese_to_prol'] >= MCS_RESE_TO_PROL:
            cell.type = CELL_TYPE_PROL
            self.transition_counts["RESE‚ÜíPROL"] += 1
            logging.info(f"üîÑ RESE ‚Üí PROL in cell {cell.id} at MCS {mcs}")
    
        # INVA ‚Üí RESE
        elif conditions['high_o2_high_glu_inva_to_rese'] >= MCS_INVA_TO_RESE:
            cell.type = CELL_TYPE_RESE
            self.transition_counts["INVA‚ÜíRESE"] += 1
            logging.info(f"üîÑ INVA ‚Üí RESE in cell {cell.id} at MCS {mcs}")
    
    def get_new_cell_type(self, current_type):
        """Devuelve un nuevo tipo de c√©lula basado en el tipo actual."""
        if current_type == CELL_TYPE_PROL:
            return random.choice([CELL_TYPE_RESE, CELL_TYPE_INVA])
        elif current_type == CELL_TYPE_RESE:
            return random.choice([CELL_TYPE_PROL, CELL_TYPE_INVA])
        else:
            return random.choice([CELL_TYPE_PROL, CELL_TYPE_RESE])
                
    def perform_random_mutations(self, mcs):
        """Realiza mutaciones aleatorias en c√©lulas cada `mutation_interval` pasos."""
        if mcs < self.initial_mutation_delay or mcs % self.mutation_interval != 0:
            return        
        eligible_cells = [cell for cell in self.cell_list if cell.type in [CELL_TYPE_PROL, CELL_TYPE_RESE, CELL_TYPE_INVA]]
        if eligible_cells:
            num_mutations = max(1, int(len(eligible_cells) * self.mutation_percentage))
            cells_to_mutate = random.sample(eligible_cells, min(num_mutations, len(eligible_cells)))

            for cell in cells_to_mutate:
                new_type = self.get_new_cell_type(cell.type)
                cell.type = new_type
                self.mutation_count += 1
                logging.info(f"üîÄ Mutaci√≥n aleatoria: C√©lula {cell.id} ahora es tipo {new_type} en MCS {mcs}.")      \
    
    def finish(self):
        try:
            output_file = os.path.join(OUTPUT_DIR, "transition_counts.csv")
            with open(output_file, "w", newline="") as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(["Transition", "Count"])
                for key, val in self.transition_counts.items():
                    writer.writerow([key, val])
    
            logging.info("üì§ Exportaci√≥n de conteos de transici√≥n finalizada: transition_counts.csv en SimulationOutputs/")
    
        except Exception as e:
            logging.error(f"‚ùå Error exportando transition_counts.csv: {e}")    
              
